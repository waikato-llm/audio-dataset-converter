import base64
import copy
import io
import logging
import os.path
import shutil
import soundfile as sf
from typing import Dict, Optional, Any

import numpy as np
from seppl import MetaDataHandler, LoggingHandler, get_class_name
from tinytag import TinyTag

from ._utils import load_audio_from_bytes, load_audio_from_file

FORMAT_FLAC = "FLAC"
FORMAT_MP3 = "MP3"
FORMAT_OGG = "OGG"
FORMAT_WAV = "WAV"
FORMATS = [
    FORMAT_FLAC,
    FORMAT_MP3,
    FORMAT_OGG,
    FORMAT_WAV,
]
FORMAT_EXTENSIONS = {
    FORMAT_FLAC: ".flac",
    FORMAT_MP3: ".mp3",
    FORMAT_OGG: ".ogg",
    FORMAT_WAV: ".wav",
}


def determine_audio_format_from_ext(s: str) -> Optional[str]:
    """
    Determines the file format from the extension.

    :param s: the path or filename to use
    :type s: str
    :return: the file format, None if failed to determine
    :rtype: str
    """
    s = s.lower()
    for f, e in FORMAT_EXTENSIONS.items():
        if s.endswith(e):
            return f
    return None


def determine_audio_format_from_bytes(b: bytes) -> Optional[str]:
    """
    Determines the file format from the binary audio data.

    :param b: the bytes of the audio file
    :type b: bytes
    :return: the file format, None if failed to determine
    :rtype: str
    """
    if len(b) > 4:
        if b[0:3].decode("utf-8") == "ID3":
            return FORMAT_MP3
        elif b[0:4].decode("utf-8") == "RIFF":
            return FORMAT_WAV
        elif b[0:4].decode("utf-8") == "OggS":
            return FORMAT_OGG
        elif b[0:4].decode("utf-8") == "fLaC":
            return FORMAT_FLAC
    return None


class AudioData(MetaDataHandler, LoggingHandler):

    def __init__(self, source: str = None, audio_name: str = None, data: bytes = None,
                 audio: np.ndarray = None, audio_format: str = None,
                 duration: float = None, sample_rate: float = None,
                 metadata: Dict = None, annotation=None):

        # container with audio or data must have source or name
        if (audio is not None) or (data is not None):
            if (source is None) and (audio_name is None):
                raise Exception("Either source or name must be provided!")

        self._logger = None
        """ for logging. """
        self._source = source
        """ the full path to the audio file. """
        self._audio_name = audio_name
        """ the name of the audio file (no path). """
        self._data = data
        """ the binary audio data. """
        self._audio = audio
        """ the audio data structure. """
        self._audio_format = audio_format
        """ the format of the audio. """
        self._duration = duration
        """ the duration in seconds. """
        self._sample_rate = sample_rate
        """ the sample rate (samples per second). """
        self._metadata = metadata
        """ the dictionary with optional meta-data. """
        self._annotation = None
        """ the associated annotation data. """
        self.annotation = annotation
        self._tag = None
        """ the metadata from the audio data. """

    def logger(self) -> logging.Logger:
        """
        Returns the logger instance to use.

        :return: the logger
        :rtype: logging.Logger
        """
        if self._logger is None:
            self._logger = logging.getLogger(self.__class__.__name__)
        return self._logger

    @property
    def source(self) -> Optional[str]:
        """
        Returns the source filename.

        :return: the full filename, if available
        :rtype: str
        """
        return self._source

    @property
    def audio(self) -> np.ndarray:
        """
        Returns the audio, loads it if necessary.

        :return: the audio data structure, None if not available or failed to load
        :rtype: np.ndarray
        """
        if self._audio is not None:
            return self._audio
        if (self._data is not None) and (self._audio_name is not None):
            audio_format = determine_audio_format_from_ext(self._audio_name)
            self._audio, self._sample_rate = load_audio_from_bytes(self._data, audio_format)
            self._audio_format = audio_format
            return self._audio
        if self._source is not None:
            self._audio_name = os.path.basename(self._source)
            self._audio, self._sample_rate = load_audio_from_file(self._source)
            self._audio_format = determine_audio_format_from_ext(self._source)
            return self._audio
        return None

    @property
    def audio_bytes(self):
        """
        Turns the audio into bytes using the current audio format.

        :return: the generated bytes
        """
        buffer = io.BytesIO()
        if self.audio is not None:
            sf.write(buffer, self.audio, self.sample_rate, format=self.audio_format)
        return buffer.getvalue()

    @property
    def audio_name(self) -> Optional[str]:
        """
        Returns the name of the audio file.

        :return: the audio file name, can be None
        :rtype: str
        """
        if self._audio_name is not None:
            return self._audio_name
        elif self.source is not None:
            return os.path.basename(self.source)
        else:
            return None

    @audio_name.setter
    def audio_name(self, s: str):
        """
        Sets the new name.

        :param s: the new name
        :type s: str
        """
        self._audio_name = s

    @property
    def audio_format(self) -> Optional[str]:
        """
        Returns the format of the audio file.

        :return: the audio file format, can be None
        :rtype: str
        """
        if self._audio_format is None:
            if self._audio_name is not None:
                self._audio_format = determine_audio_format_from_ext(self._audio_name)
        return self._audio_format

    def _read_tags(self):
        """
        Reads relevant tag information from the bytes or audio file.
        """
        if self._tag is not None:
            return

        if self._data is not None:
            try:
                self._tag = TinyTag.get(io.BytesIO(self._data))
                self._duration = self._tag.duration
                self._sample_rate = self._tag.samplerate
            except:
                pass

        elif self._source is not None:
            try:
                self._tag = TinyTag.get(self._source)
                self._duration = self._tag.duration
                self._sample_rate = self._tag.samplerate
            except:
                pass

    @property
    def duration(self) -> Optional[float]:
        """
        Returns the duration in seconds.

        :return: the duration, None if failed to determine
        :rtype: float
        """
        if self._duration is None:
            self._read_tags()
        return self._duration

    @property
    def sample_rate(self) -> Optional[int]:
        """
        Returns the sample rate of the audio file.

        :return: the sample rate, None if failed to determine
        :rtype: int
        """
        if self._sample_rate is None:
            self._read_tags()
        return self._sample_rate

    @property
    def is_mono(self) -> bool:
        """
        Returns whether the audio data is mono or stereo.

        :return: True if mono
        :rtype: bool
        """
        if self.source is not None:
            return TinyTag.get(self.source).channels == 1
        else:
            return len(self.audio[0].shape) == 1

    @property
    def data(self) -> bytes:
        """
        Returns the internal data, if any.

        :return: the data
        """
        return self._data

    @data.setter
    def data(self, data: bytes):
        """
        Uses the provided data.

        :param data: the data to use
        """
        self._audio_name = self.audio_name
        self._source = None
        self._audio_format = None
        self._duration = None
        self._sample_rate = None
        self._data = data

    def save_audio(self, path: str, make_dirs: bool = False) -> bool:
        """
        Saves the audio under the specified path.

        :param path: the path to save the audio under
        :type path: str
        :param make_dirs: whether to create any missing parent dirs
        :type make_dirs: bool
        :return: whether the file was saved
        :rtype: bool
        """
        if self._source is not None:
            if os.path.exists(path) and os.path.exists(self._source) and os.path.samefile(path, self._source):
                self.logger().warning("Input/output audio file are the same, skipping!")
                return False
        if make_dirs:
            parent_dir = os.path.dirname(path)
            if not os.path.exists(parent_dir):
                self.logger().info("Creating dir: %s" % parent_dir)
                os.makedirs(parent_dir)
        if (self._data is None) and (self._source is not None) and (os.path.exists(self._source)):
            shutil.copy(self._source, path)
            return True
        if self._audio is not None:
            sf.write(path, self._audio, self.sample_rate)
            return True
        if self._data is not None:
            with open(path, "wb") as fp:
                fp.write(self._data)
            return True
        return False

    @property
    def annotation(self) -> Optional[Any]:
        """
        Returns the current annotation, if any.

        :return: the annotation
        """
        return self._annotation

    @annotation.setter
    def annotation(self, ann: Optional[Any]):
        """
        Sets the annotation to use.

        :param ann: the annotation, can be None
        """
        self._annotation = self._check_annotation(ann)

    def _is_correct_annotation_type(self, ann: Any):
        """
        Checks whether the annotation type is valid. Raises an exception if not.
        Default annotations performs no check.

        :param ann: the annotations to check
        """
        pass

    def _check_annotation(self, ann: Optional[Any]):
        """
        Checks whether the annotations are valid. Raises an exception if invalid type.
        Ignores None values.

        :param ann: the annotations to check, can be None
        :return: the annotations
        """
        if ann is not None:
            self._is_correct_annotation_type(ann)
        return ann

    def has_annotation(self) -> bool:
        """
        Checks whether annotations are present.

        :return: True if annotations present
        :rtype: bool
        """
        return self.annotation is not None

    def set_annotation(self, ann: Optional[Any]):
        """
        Sets the annotations.

        :param ann: the annotations
        """
        self.annotation = ann

    def get_annotation(self) -> Optional[Any]:
        """
        Returns the annotations.

        :return: the annotations
        """
        return self.annotation

    def has_metadata(self) -> bool:
        """
        Returns whether meta-data is present.

        :return: True if meta-data present
        :rtype: bool
        """
        return self._metadata is not None

    def get_metadata(self) -> Optional[Dict]:
        """
        Returns the meta-data.

        :return: the meta-data, None if not available
        :rtype: dict
        """
        return self._metadata

    def set_metadata(self, metadata: Optional[Dict]):
        """
        Sets the meta-data to use.

        :param metadata: the new meta-data, can be None
        :type metadata: dict
        """
        self._metadata = metadata

    def duplicate(self, source: str = None, force_no_source: bool = None,
                  name: str = None, data: bytes = None,
                  audio: np.ndarray = None, audio_format: str = None,
                  duration: float = None, sample_rate: float = None,
                  metadata: Dict = None, annotation=None):
        """
        Duplicates the container overwriting existing data with any provided data.

        :param source: the source to use
        :type source: str
        :param force_no_source: if True, then source is set to None
        :type force_no_source: bool
        :param name: the name to use
        :type name: str
        :param data: the data to use
        :type data: bytes
        :param audio: the Pillow audio to use
        :type audio: Image.Image
        :param audio_format: the audio format
        :type audio_format: str
        :param duration: the duration in seconds
        :type duration: float
        :param sample_rate: the sample rate (per second)
        :type sample_rate: float
        :param metadata: the metadata
        :type metadata: dict
        :param annotation: the annotations
        :return: the duplicated container
        """
        if (force_no_source is not None) and force_no_source:
            source = None
        else:
            if source is None:
                source = self._source
        if name is None:
            name = self._audio_name
        if (data is None) and (self._data is not None):
            data = copy.deepcopy(self._data)
        # if the source changes, we need to force loading the audio
        if ((audio is None) and (self._audio is not None)) or (source != self._source):
            audio = copy.deepcopy(self.audio)
        if audio_format is None:
            audio_format = self._audio_format
        if (duration is None) and (self._duration is not None):
            duration = self._duration
        if (sample_rate is None) and (self._sample_rate is not None):
            sample_rate = self._sample_rate
        if (metadata is None) and (self._metadata is not None):
            metadata = copy.deepcopy(self._metadata)
        if (annotation is None) and (self.annotation is not None):
            annotation = copy.deepcopy(self.annotation)

        return type(self)(source=source, audio_name=name, data=data,
                          audio=audio, audio_format=audio_format,
                          duration=duration, sample_rate=sample_rate,
                          metadata=metadata, annotation=annotation)

    def _annotation_to_dict(self):
        """
        Turns the annotations into a dictionary.

        :return: the generated dictionary
        :rtype: dict
        """
        raise NotImplementedError()

    def to_dict(self, source: bool = True, audio: bool = True, annotation: bool = True, metadata: bool = True):
        """
        Returns itself as a dictionary that can be saved as JSON.

        :param source: whether to include the source
        :type source: bool
        :param audio: whether to include the audio
        :type audio: bool
        :param annotation: whether to include the annotations
        :type annotation: bool
        :param metadata: whether to include the metadata
        :type metadata: bool
        :return: the generated dictionary
        :rtype: dict
        """
        result = dict()
        if source and (self.source is not None):
            result["source"] = self.source
        if self.audio_name is not None:
            result["name"] = self.audio_name
        if self.audio_format is not None:
            result["format"] = self.audio_format
        if self.duration is not None:
            result["duration"] = self.duration
        if self.sample_rate is not None:
            result["sample_rate"] = self.sample_rate
        if audio:
            result["audio"] = base64.encodebytes(self.audio_bytes).decode("ascii")
        if annotation and (self.annotation is not None):
            result["annotation"] = self._annotation_to_dict()
        if metadata and (self.get_metadata() is not None):
            result["metadata"] = copy.deepcopy(self.get_metadata())
        return result

    def __str__(self) -> str:
        """
        Returns a basic description of the container.

        :return: the description
        :rtype: str
        """
        return "name=" + self.audio_name + ", annotation=" + str(self.has_annotation()) + ", type=" + str(get_class_name(self)) + ", metadata=" + str(self.get_metadata())
